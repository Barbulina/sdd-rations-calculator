/**
 * Repository Interface: Ration Persistence Abstraction
 *
 * This interface defines the contract for ration data persistence.
 * Implementations can use localStorage, IndexedDB, REST API, GraphQL, etc.
 *
 * The repository pattern provides:
 * - Abstraction over data source (implementation details hidden)
 * - Testability (easy to mock for unit tests)
 * - Flexibility (swap implementations without changing business logic)
 * - Single Responsibility (data access logic separated from components)
 *
 * @see ../research.md for repository pattern best practices
 */

import {
  Ration,
  CreateRationDTO,
  UpdateRationDTO,
  RationFilters,
} from "./types";

/**
 * RationRepository Interface
 *
 * Defines CRUD operations for Ration entities.
 * All methods are async to support future migration to async storage (API, IndexedDB).
 */
export interface RationRepository {
  /**
   * Save a new ration
   *
   * @param data - Ration data without id and createdAt (generated by repository)
   * @returns Promise resolving to the created ration with id and createdAt
   * @throws {RepositoryError} If save fails (e.g., localStorage quota exceeded)
   *
   * @example
   * ```typescript
   * const newRation = await repository.save({
   *   type: RationsType.fruits,
   *   name: "Manzana",
   *   gramsToCarbohydrate: 150,
   *   weight: 200,
   *   rations: 1.33
   * });
   * console.log(newRation.id); // "550e8400-e29b-41d4-a716-446655440000"
   * ```
   */
  save(data: CreateRationDTO): Promise<Ration>;

  /**
   * Find all rations
   *
   * @returns Promise resolving to array of all rations, sorted by createdAt DESC (newest first)
   * @throws {RepositoryError} If retrieval fails
   *
   * @example
   * ```typescript
   * const allRations = await repository.findAll();
   * console.log(allRations.length); // 42
   * ```
   */
  findAll(): Promise<Ration[]>;

  /**
   * Find ration by ID
   *
   * @param id - Unique identifier of the ration
   * @returns Promise resolving to the ration if found, null otherwise
   * @throws {RepositoryError} If retrieval fails
   *
   * @example
   * ```typescript
   * const ration = await repository.findById("550e8400-...");
   * if (ration) {
   *   console.log(ration.name); // "Manzana"
   * }
   * ```
   */
  findById(id: string): Promise<Ration | null>;

  /**
   * Update an existing ration
   *
   * @param data - Partial ration data with id (only provided fields are updated)
   * @returns Promise resolving to the updated ration
   * @throws {RepositoryError} If update fails or ration not found
   *
   * @example
   * ```typescript
   * const updated = await repository.update({
   *   id: "550e8400-...",
   *   weight: 300, // Only update weight
   *   rations: 2.0  // And recalculated rations
   * });
   * ```
   */
  update(data: UpdateRationDTO): Promise<Ration>;

  /**
   * Delete a ration by ID
   *
   * @param id - Unique identifier of the ration to delete
   * @returns Promise resolving to true if deleted, false if not found
   * @throws {RepositoryError} If deletion fails
   *
   * @example
   * ```typescript
   * const deleted = await repository.delete("550e8400-...");
   * if (deleted) {
   *   console.log("Ration deleted successfully");
   * }
   * ```
   */
  delete(id: string): Promise<boolean>;

  /**
   * Find rations matching filters
   *
   * @param filters - Optional filtering criteria
   * @returns Promise resolving to array of matching rations
   * @throws {RepositoryError} If query fails
   *
   * @example
   * ```typescript
   * const fruits = await repository.findByFilters({
   *   types: [RationsType.fruits, RationsType.vegetables]
   * });
   * ```
   *
   * @note MVP implementation may not support all filters initially
   */
  findByFilters(filters: RationFilters): Promise<Ration[]>;

  /**
   * Count total number of rations
   *
   * @returns Promise resolving to total count
   * @throws {RepositoryError} If count fails
   *
   * @example
   * ```typescript
   * const total = await repository.count();
   * console.log(`You have ${total} rations`);
   * ```
   */
  count(): Promise<number>;

  /**
   * Delete all rations (use with caution!)
   *
   * @returns Promise resolving to number of deleted rations
   * @throws {RepositoryError} If deletion fails
   *
   * @example
   * ```typescript
   * const deletedCount = await repository.deleteAll();
   * console.log(`Deleted ${deletedCount} rations`);
   * ```
   *
   * @note Should show confirmation dialog before calling this method
   */
  deleteAll(): Promise<number>;
}

/**
 * RepositoryError
 *
 * Custom error type for repository operations.
 * Provides structured error information for handling in UI.
 */
export class RepositoryError extends Error {
  constructor(
    message: string,
    public readonly code: RepositoryErrorCode,
    public readonly originalError?: unknown,
  ) {
    super(message);
    this.name = "RepositoryError";
  }
}

/**
 * RepositoryErrorCode
 *
 * Enumeration of possible repository error types.
 */
export enum RepositoryErrorCode {
  /** localStorage quota exceeded (typically 5-10MB) */
  QUOTA_EXCEEDED = "QUOTA_EXCEEDED",

  /** localStorage is disabled in browser settings or private browsing */
  STORAGE_DISABLED = "STORAGE_DISABLED",

  /** Data in storage is corrupted or invalid JSON */
  CORRUPTED_DATA = "CORRUPTED_DATA",

  /** Requested ration not found by ID */
  NOT_FOUND = "NOT_FOUND",

  /** Validation failed (data doesn't conform to schema) */
  VALIDATION_ERROR = "VALIDATION_ERROR",

  /** Unknown/unexpected error */
  UNKNOWN = "UNKNOWN",
}

/**
 * Repository Factory Type
 *
 * Function signature for creating repository instances.
 * Useful for dependency injection and testing.
 */
export type RepositoryFactory = () => RationRepository;

/**
 * Mock Repository for Testing
 *
 * Simple in-memory implementation for unit tests.
 * Does not persist data between test runs.
 *
 * @example
 * ```typescript
 * const mockRepo: RationRepository = new MockRationRepository();
 * await mockRepo.save({ ... }); // Stored in memory only
 * ```
 */
export class MockRationRepository implements RationRepository {
  private rations: Ration[] = [];

  async save(data: CreateRationDTO): Promise<Ration> {
    const ration: Ration = {
      ...data,
      id: crypto.randomUUID(),
      createdAt: new Date(),
    };
    this.rations.push(ration);
    return ration;
  }

  async findAll(): Promise<Ration[]> {
    return [...this.rations].sort(
      (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),
    );
  }

  async findById(id: string): Promise<Ration | null> {
    return this.rations.find((r) => r.id === id) ?? null;
  }

  async update(data: UpdateRationDTO): Promise<Ration> {
    const index = this.rations.findIndex((r) => r.id === data.id);
    if (index === -1) {
      throw new RepositoryError(
        "Ration not found",
        RepositoryErrorCode.NOT_FOUND,
      );
    }
    this.rations[index] = { ...this.rations[index], ...data };
    return this.rations[index];
  }

  async delete(id: string): Promise<boolean> {
    const index = this.rations.findIndex((r) => r.id === id);
    if (index === -1) return false;
    this.rations.splice(index, 1);
    return true;
  }

  async findByFilters(filters: RationFilters): Promise<Ration[]> {
    let results = [...this.rations];

    if (filters.types?.length) {
      results = results.filter((r) => filters.types!.includes(r.type));
    }

    if (filters.nameSearch) {
      const search = filters.nameSearch.toLowerCase();
      results = results.filter((r) => r.name.toLowerCase().includes(search));
    }

    return results.sort(
      (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),
    );
  }

  async count(): Promise<number> {
    return this.rations.length;
  }

  async deleteAll(): Promise<number> {
    const count = this.rations.length;
    this.rations = [];
    return count;
  }

  /** Test helper: reset repository to empty state */
  reset(): void {
    this.rations = [];
  }
}
